# 助手-贾维斯 后端服务 - 技术架构设计文档

**版本**: V1.0  
**日期**: 2025-11-08  
**状态**: 正式版

---

## 目录

1. [架构概述](#1-架构概述)
2. [技术栈选型](#2-技术栈选型)
3. [系统架构设计](#3-系统架构设计)
4. [核心服务模块](#4-核心服务模块)
5. [数据库设计](#5-数据库设计)
6. [WebSocket实时通信](#6-websocket实时通信)
7. [安全设计](#7-安全设计)
8. [性能优化](#8-性能优化)
9. [部署架构](#9-部署架构)
10. [开发规范](#10-开发规范)

---

## 1. 架构概述

### 1.1 设计目标

后端服务是"助手-贾维斯"的云端服务层，主要职责：

- **为 PC 客户端提供 API 服务**（Phase 1 核心）
  - 用户认证与管理
  - 工作流 CRUD 和同步
  - 任务执行状态同步
  - 文件存储服务
  - 日志收集与监控
  - WebSocket 实时通信

- **为移动端提供监控 API**（Phase 5）
  - 实时状态查询
  - 远程控制指令

- **为管理后台提供管理 API**（Phase 2+）
  - 用户管理
  - 数据统计
  - 内容审核

### 1.2 核心设计原则

- **BaaS 优先**: 基于 Supabase，快速开发，降低运维成本
- **API First**: RESTful API + WebSocket，前后端完全分离
- **安全可靠**: JWT 认证 + RLS 数据隔离 + 审计日志
- **高性能**: Redis 缓存 + 数据库优化 + CDN 加速
- **易扩展**: 模块化设计，支持水平扩展

---

## 2. 技术栈选型

### 2.1 核心技术

| 技术 | 版本 | 用途 | 选型理由 |
|------|------|------|---------|
| Go | 1.21+ | 编程语言 | 高性能、高并发、部署简单 |
| Gin | 1.9+ | Web 框架 | 轻量级、性能优秀、生态丰富 |
| Supabase | - | BaaS 平台 | 提供数据库、认证、存储、实时订阅等一体化服务 |
| PostgreSQL | 15+ | 关系数据库 | Supabase 内置，功能强大，支持 JSON、数组、向量检索 |
| Redis | 7.x | 缓存 | 高性能缓存，支持多种数据结构 |
| WebSocket | - | 实时通信 | 双向实时通信，支持状态同步和远程控制 |

### 2.2 第三方服务

| 服务 | 用途 |
|------|------|
| Supabase Auth | 用户认证和 JWT 管理 |
| Supabase Storage | 文件存储（工作流、截图、图标等） |
| Supabase Realtime | 实时数据推送（可选） |
| Sentry | 错误监控和追踪 |
| 阿里云智能媒体 | AI 通话服务（Phase 3） |
| 微信支付/支付宝 | 支付服务（Phase 2+） |

---

## 3. 系统架构设计

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         客户端层                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │  PC 客户端   │  │  移动端 App  │  │  管理后台    │         │
│  │  (Tauri 2)   │  │(React Native)│  │  (React)     │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
└─────────────────────────────────────────────────────────────────┘
            ↕ HTTPS/WebSocket           ↕ HTTPS        ↕ HTTPS
┌─────────────────────────────────────────────────────────────────┐
│                         API 网关层                               │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Go API Server (Gin)                                     │  │
│  │  - 路由分发                                              │  │
│  │  - JWT 认证中间件                                        │  │
│  │  - 日志中间件                                            │  │
│  │  - 限流中间件                                            │  │
│  │  - CORS 中间件                                           │  │
│  │  - WebSocket 管理器                                      │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                         业务服务层                               │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐               │
│  │ 用户服务   │  │ 工作流服务 │  │ 任务服务   │               │
│  └────────────┘  └────────────┘  └────────────┘               │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐               │
│  │ 文件服务   │  │ 日志服务   │  │ 设备服务   │               │
│  └────────────┘  └────────────┘  └────────────┘               │
└─────────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                         数据访问层                               │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐               │
│  │ Supabase   │  │ Supabase   │  │ Redis      │               │
│  │ PostgreSQL │  │ Storage    │  │ (缓存)     │               │
│  └────────────┘  └────────────┘  └────────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 数据流向

**PC 端工作流同步流程**:
```
PC 客户端 → API (JWT 认证) → 业务服务 → Supabase → 返回结果
```

**任务状态实时推送流程**:
```
PC 客户端 → WebSocket 连接 → 上报任务状态 → 广播给订阅者（移动端）
```

**文件上传流程**:
```
PC 客户端 → API → 业务服务 → Supabase Storage → 返回 URL
```

---

## 4. 核心服务模块

### 4.1 项目结构

```
backend/
├── cmd/
│   └── server/
│       └── main.go            # 应用入口
├── internal/
│   ├── api/                   # API 层（路由和控制器）
│   │   ├── middleware/        # 中间件
│   │   │   ├── auth.go        # JWT 认证
│   │   │   ├── cors.go        # CORS 配置
│   │   │   ├── logger.go      # 日志记录
│   │   │   └── rate_limit.go  # 限流
│   │   ├── handler/           # 处理器
│   │   │   ├── auth.go        # 认证相关
│   │   │   ├── user.go        # 用户管理
│   │   │   ├── workflow.go    # 工作流管理
│   │   │   ├── task.go        # 任务管理
│   │   │   ├── file.go        # 文件管理
│   │   │   ├── log.go         # 日志管理
│   │   │   └── device.go      # 设备管理
│   │   ├── websocket/         # WebSocket 管理
│   │   │   ├── hub.go         # WebSocket Hub
│   │   │   └── client.go      # 客户端连接
│   │   └── router.go          # 路由注册
│   ├── service/               # 业务逻辑层
│   │   ├── auth_service.go
│   │   ├── user_service.go
│   │   ├── workflow_service.go
│   │   ├── task_service.go
│   │   ├── file_service.go
│   │   ├── log_service.go
│   │   └── device_service.go
│   ├── repository/            # 数据访问层
│   │   ├── user_repo.go
│   │   ├── workflow_repo.go
│   │   ├── task_repo.go
│   │   ├── log_repo.go
│   │   └── device_repo.go
│   ├── model/                 # 数据模型
│   │   ├── user.go
│   │   ├── workflow.go
│   │   ├── task.go
│   │   ├── log.go
│   │   └── device.go
│   ├── pkg/                   # 工具包
│   │   ├── supabase/         # Supabase 客户端封装
│   │   ├── cache/            # Redis 缓存封装
│   │   ├── logger/           # 日志封装
│   │   └── utils/            # 通用工具
│   └── config/               # 配置
│       └── config.go
├── migrations/               # 数据库迁移脚本
│   └── 001_init.sql
├── docs/                     # 文档
│   ├── api.md                # API 文档
│   └── 技术架构设计.md
├── .env.example              # 环境变量示例
├── go.mod
└── go.sum
```

### 4.2 核心模块实现

#### 4.2.1 认证服务

```go
// internal/service/auth_service.go
package service

import (
    "context"
    "github.com/supabase-community/supabase-go"
)

type AuthService struct {
    supabaseClient *supabase.Client
}

func NewAuthService(client *supabase.Client) *AuthService {
    return &AuthService{
        supabaseClient: client,
    }
}

// Register 用户注册
func (s *AuthService) Register(ctx context.Context, email, password string) (*model.User, error) {
    // 使用 Supabase Auth 注册
    resp, err := s.supabaseClient.Auth.SignUp(email, password)
        if err != nil {
        return nil, err
    }
    
    // 创建用户 Profile
    user := &model.User{
        ID:              resp.User.ID,
        Email:           email,
        MembershipLevel: "free",
        StorageQuotaMB:  1000,
        TokenQuota:      100000,
    }
    
    // 保存到 user_profiles 表
    _, err = s.supabaseClient.DB.
        From("user_profiles").
        Insert(user).
        Execute()
    
    return user, err
        }
        
// Login 用户登录
func (s *AuthService) Login(ctx context.Context, email, password string) (string, error) {
    // 使用 Supabase Auth 登录
    resp, err := s.supabaseClient.Auth.SignIn(email, password)
    if err != nil {
        return "", err
    }
    
    // 返回 JWT Token
    return resp.AccessToken, nil
}

// VerifyToken 验证 Token
func (s *AuthService) VerifyToken(ctx context.Context, token string) (*model.User, error) {
    // 使用 Supabase Auth 验证
    user, err := s.supabaseClient.Auth.User(token)
    if err != nil {
        return nil, err
    }
    
    // 获取用户 Profile
    var profile model.User
    err = s.supabaseClient.DB.
        From("user_profiles").
        Select("*").
        Eq("id", user.ID).
        Single().
        Execute(&profile)
    
    return &profile, err
}
```

#### 4.2.2 工作流服务

```go
// internal/service/workflow_service.go
package service

type WorkflowService struct {
    workflowRepo  *repository.WorkflowRepository
    cacheRepo     *repository.CacheRepository
    storageClient *supabase.Storage
}

func NewWorkflowService(
    workflowRepo *repository.WorkflowRepository,
    cacheRepo *repository.CacheRepository,
    storageClient *supabase.Storage,
) *WorkflowService {
    return &WorkflowService{
        workflowRepo:  workflowRepo,
        cacheRepo:     cacheRepo,
        storageClient: storageClient,
    }
}

// CreateWorkflow 创建工作流
func (s *WorkflowService) CreateWorkflow(ctx context.Context, userID string, req *model.CreateWorkflowRequest) (*model.Workflow, error) {
    workflow := &model.Workflow{
        UserID:      userID,
        Name:        req.Name,
        Description: req.Description,
        Category:    req.Category,
        Tags:        req.Tags,
        Version:     "1.0.0",
        Definition:  req.Definition,
    }
    
    // 保存到数据库
    if err := s.workflowRepo.Create(ctx, workflow); err != nil {
        return nil, err
    }
    
    // 清除缓存
    s.cacheRepo.DeletePattern(ctx, fmt.Sprintf("workflows:user:%s:*", userID))
    
    return workflow, nil
}

// GetWorkflows 获取工作流列表
func (s *WorkflowService) GetWorkflows(ctx context.Context, userID string, params *model.WorkflowQueryParams) (*model.WorkflowListResponse, error) {
    // 尝试从缓存获取
    cacheKey := fmt.Sprintf("workflows:user:%s:%v", userID, params)
    cached, err := s.cacheRepo.Get(ctx, cacheKey)
    if err == nil && cached != nil {
        return cached.(*model.WorkflowListResponse), nil
    }
    
    // 从数据库查询
    workflows, total, err := s.workflowRepo.FindByUserID(ctx, userID, params)
    if err != nil {
        return nil, err
    }
    
    response := &model.WorkflowListResponse{
        List:  workflows,
        Total: total,
    }
    
    // 写入缓存（5 分钟）
    s.cacheRepo.Set(ctx, cacheKey, response, 5*time.Minute)
    
    return response, nil
}

// UpdateWorkflow 更新工作流
func (s *WorkflowService) UpdateWorkflow(ctx context.Context, workflowID, userID string, req *model.UpdateWorkflowRequest) error {
    // 验证权限
    workflow, err := s.workflowRepo.FindByID(ctx, workflowID)
    if err != nil {
        return err
    }
    if workflow.UserID != userID {
        return errors.New("无权限")
    }
    
    // 更新数据库
    if err := s.workflowRepo.Update(ctx, workflowID, req); err != nil {
        return err
    }
    
    // 清除缓存
    s.cacheRepo.Delete(ctx, fmt.Sprintf("workflow:%s", workflowID))
    s.cacheRepo.DeletePattern(ctx, fmt.Sprintf("workflows:user:%s:*", userID))
    
    return nil
}
```

#### 4.2.3 任务服务

```go
// internal/service/task_service.go
package service

type TaskService struct {
    taskRepo  *repository.TaskRepository
    wsHub     *websocket.Hub // WebSocket Hub，用于实时推送
}

func NewTaskService(taskRepo *repository.TaskRepository, wsHub *websocket.Hub) *TaskService {
    return &TaskService{
        taskRepo: taskRepo,
        wsHub:    wsHub,
    }
}

// CreateTask 创建任务
func (s *TaskService) CreateTask(ctx context.Context, req *model.CreateTaskRequest) (*model.Task, error) {
    task := &model.Task{
        WorkflowID: req.WorkflowID,
        UserID:     req.UserID,
        DeviceID:   req.DeviceID,
        Status:     "pending",
        Priority:   req.Priority,
        Parameters: req.Parameters,
    }
    
    // 保存到数据库
    if err := s.taskRepo.Create(ctx, task); err != nil {
        return nil, err
    }
    
    // 通过 WebSocket 推送给移动端
    s.wsHub.BroadcastToUser(req.UserID, map[string]interface{}{
        "type": "task_created",
        "data": task,
    })
    
    return task, nil
}

// UpdateTaskStatus 更新任务状态
func (s *TaskService) UpdateTaskStatus(ctx context.Context, taskID string, status string, result map[string]interface{}) error {
    // 更新数据库
    if err := s.taskRepo.UpdateStatus(ctx, taskID, status, result); err != nil {
        return err
    }
    
    // 获取任务信息
    task, err := s.taskRepo.FindByID(ctx, taskID)
    if err != nil {
    return err
}
    
    // 通过 WebSocket 实时推送
    s.wsHub.BroadcastToUser(task.UserID, map[string]interface{}{
        "type": "task_status_updated",
        "data": map[string]interface{}{
            "task_id": taskID,
            "status":  status,
            "result":  result,
        },
    })
    
    return nil
}

// GetTaskHistory 获取任务历史
func (s *TaskService) GetTaskHistory(ctx context.Context, userID string, params *model.TaskQueryParams) (*model.TaskListResponse, error) {
    tasks, total, err := s.taskRepo.FindByUserID(ctx, userID, params)
    if err != nil {
        return nil, err
    }
    
    return &model.TaskListResponse{
        List:  tasks,
        Total: total,
    }, nil
}
```

### 4.3 API 设计规范

#### 4.3.1 RESTful API 规范

```
# 认证相关
POST   /api/v1/auth/register           # 用户注册
POST   /api/v1/auth/login              # 用户登录
POST   /api/v1/auth/logout             # 用户登出
POST   /api/v1/auth/refresh            # 刷新 Token
POST   /api/v1/auth/reset-password     # 重置密码

# 用户管理
GET    /api/v1/users/profile           # 获取当前用户信息
PUT    /api/v1/users/profile           # 更新用户信息
GET    /api/v1/users/devices           # 获取设备列表
POST   /api/v1/users/devices           # 注册设备
PUT    /api/v1/users/devices/:id       # 更新设备状态

# 工作流管理
GET    /api/v1/workflows               # 获取工作流列表
POST   /api/v1/workflows               # 创建工作流
GET    /api/v1/workflows/:id           # 获取工作流详情
PUT    /api/v1/workflows/:id           # 更新工作流
DELETE /api/v1/workflows/:id           # 删除工作流
POST   /api/v1/workflows/:id/export    # 导出工作流
POST   /api/v1/workflows/import        # 导入工作流

# 任务管理
GET    /api/v1/tasks                   # 获取任务列表
POST   /api/v1/tasks                   # 创建任务
GET    /api/v1/tasks/:id               # 获取任务详情
PUT    /api/v1/tasks/:id/status        # 更新任务状态
DELETE /api/v1/tasks/:id               # 删除任务

# 文件管理
POST   /api/v1/files/upload            # 文件上传
GET    /api/v1/files/:id               # 获取文件信息
DELETE /api/v1/files/:id               # 删除文件

# 日志管理
POST   /api/v1/logs                    # 上报日志
GET    /api/v1/logs                    # 获取日志列表
```

#### 4.3.2 统一响应格式

```go
// 成功响应
{
    "code": 0,
    "message": "success",
    "data": {
        // 业务数据
    }
}

// 分页响应
{
    "code": 0,
    "message": "success",
    "data": {
        "list": [],
        "total": 100,
        "page": 1,
        "page_size": 20
    }
}

// 错误响应
{
    "code": 40001,
    "message": "用户不存在",
    "data": null
}
```

#### 4.3.3 统一响应处理

```go
// internal/pkg/response/response.go
package response

import "github.com/gin-gonic/gin"

type Response struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data"`
}

func Success(c *gin.Context, data interface{}) {
    c.JSON(200, Response{
        Code:    0,
        Message: "success",
        Data:    data,
    })
}

func Error(c *gin.Context, code int, message string) {
    c.JSON(200, Response{
        Code:    code,
        Message: message,
        Data:    nil,
    })
}

func Pagination(c *gin.Context, list interface{}, total int64, page, pageSize int) {
    c.JSON(200, Response{
        Code:    0,
        Message: "success",
        Data: map[string]interface{}{
            "list":      list,
            "total":     total,
            "page":      page,
            "page_size": pageSize,
        },
    })
}
```

---

## 5. 数据库设计

### 5.1 核心表结构

数据库设计完全遵循 Phase 1 迭代计划中的 Schema 设计。

#### 5.1.1 用户表 (user_profiles)

```sql
-- Supabase Auth 自动创建 auth.users 表
-- 扩展用户信息表
CREATE TABLE public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username VARCHAR(50) UNIQUE,
    avatar_url TEXT,
  membership_level VARCHAR(20) DEFAULT 'free',
  membership_expires_at TIMESTAMP WITH TIME ZONE,
  storage_quota_mb INTEGER DEFAULT 1000,
  token_quota INTEGER DEFAULT 100000,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_user_profiles_username ON public.user_profiles(username);
CREATE INDEX idx_user_profiles_membership ON public.user_profiles(membership_level);
```

#### 5.1.2 工作流表 (workflows)

```sql
CREATE TABLE public.workflows (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50),
    tags TEXT[],
  icon VARCHAR(255),
  version VARCHAR(20) DEFAULT '1.0.0',
  os_requirements TEXT[],
  target_apps JSONB,
  parameters JSONB,
  definition JSONB NOT NULL,
  triggers JSONB,
  is_published BOOLEAN DEFAULT FALSE,
  is_archived BOOLEAN DEFAULT FALSE,
  execution_count INTEGER DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_workflows_user_id ON public.workflows(user_id);
CREATE INDEX idx_workflows_category ON public.workflows(category);
CREATE INDEX idx_workflows_tags ON public.workflows USING GIN(tags);
```

#### 5.1.3 任务表 (tasks)

```sql
CREATE TYPE task_status AS ENUM ('pending', 'running', 'paused', 'completed', 'failed', 'cancelled');
CREATE TYPE task_priority AS ENUM ('high', 'medium', 'low');

CREATE TABLE public.tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workflow_id UUID NOT NULL REFERENCES public.workflows(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  device_id VARCHAR(255),
  status task_status DEFAULT 'pending',
  priority task_priority DEFAULT 'medium',
  parameters JSONB,
  start_time TIMESTAMP WITH TIME ZONE,
  end_time TIMESTAMP WITH TIME ZONE,
  duration_ms INTEGER,
  result JSONB,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_tasks_workflow_id ON public.tasks(workflow_id);
CREATE INDEX idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX idx_tasks_status ON public.tasks(status);
CREATE INDEX idx_tasks_created_at ON public.tasks(created_at DESC);
```

#### 5.1.4 设备表 (devices)

```sql
CREATE TABLE public.devices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  device_id VARCHAR(255) NOT NULL,
  device_name VARCHAR(255),
  os_type VARCHAR(50),
  os_version VARCHAR(50),
  app_version VARCHAR(50),
  ip_address VARCHAR(50),
  last_online_at TIMESTAMP WITH TIME ZONE,
  is_online BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, device_id)
);

CREATE INDEX idx_devices_user_id ON public.devices(user_id);
CREATE INDEX idx_devices_is_online ON public.devices(is_online);
```

#### 5.1.5 日志表 (logs)

```sql
CREATE TYPE log_level AS ENUM ('debug', 'info', 'warn', 'error');
CREATE TYPE log_category AS ENUM ('system', 'task', 'message', 'error');

CREATE TABLE public.logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  task_id UUID REFERENCES public.tasks(id) ON DELETE CASCADE,
  level log_level NOT NULL,
  category log_category NOT NULL,
  message TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_logs_user_id ON public.logs(user_id);
CREATE INDEX idx_logs_task_id ON public.logs(task_id);
CREATE INDEX idx_logs_level ON public.logs(level);
CREATE INDEX idx_logs_created_at ON public.logs(created_at DESC);
```

### 5.2 Row Level Security (RLS) 策略

```sql
-- 启用 RLS
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.devices ENABLE ROW LEVEL SECURITY;

-- user_profiles 策略
CREATE POLICY "Users can view own profile"
  ON public.user_profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON public.user_profiles FOR UPDATE
  USING (auth.uid() = id);

-- workflows 策略
CREATE POLICY "Users can view own workflows"
  ON public.workflows FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own workflows"
  ON public.workflows FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own workflows"
  ON public.workflows FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own workflows"
  ON public.workflows FOR DELETE
  USING (auth.uid() = user_id);

-- tasks 策略
CREATE POLICY "Users can view own tasks"
  ON public.tasks FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own tasks"
  ON public.tasks FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- devices 策略
CREATE POLICY "Users can view own devices"
  ON public.devices FOR SELECT
  USING (auth.uid() = user_id);

-- logs 策略
CREATE POLICY "Users can view own logs"
  ON public.logs FOR SELECT
  USING (auth.uid() = user_id);
```

---

## 6. WebSocket 实时通信

### 6.1 WebSocket Hub 设计

```go
// internal/api/websocket/hub.go
package websocket

import (
    "sync"
)

type Hub struct {
    // 用户 ID -> 客户端连接映射
    clients map[string]map[*Client]bool
    
    // 广播消息
    broadcast chan *Message
    
    // 注册客户端
    register chan *Client
    
    // 注销客户端
    unregister chan *Client
    
    // 互斥锁
    mu sync.RWMutex
}

type Message struct {
    UserID  string
    Type    string
    Payload interface{}
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[string]map[*Client]bool),
        broadcast:  make(chan *Message, 256),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.mu.Lock()
            if _, ok := h.clients[client.UserID]; !ok {
                h.clients[client.UserID] = make(map[*Client]bool)
            }
            h.clients[client.UserID][client] = true
            h.mu.Unlock()
            
        case client := <-h.unregister:
            h.mu.Lock()
            if clients, ok := h.clients[client.UserID]; ok {
                delete(clients, client)
                if len(clients) == 0 {
                    delete(h.clients, client.UserID)
                }
            }
            close(client.send)
            h.mu.Unlock()
            
        case message := <-h.broadcast:
            h.mu.RLock()
            if clients, ok := h.clients[message.UserID]; ok {
                for client := range clients {
                    select {
                    case client.send <- message.Payload:
                    default:
                        close(client.send)
                        delete(clients, client)
                    }
                }
            }
            h.mu.RUnlock()
        }
    }
}

// BroadcastToUser 向指定用户广播消息
func (h *Hub) BroadcastToUser(userID string, payload interface{}) {
    h.broadcast <- &Message{
        UserID:  userID,
        Payload: payload,
    }
}
```

### 6.2 WebSocket 客户端

```go
// internal/api/websocket/client.go
package websocket

import (
    "github.com/gorilla/websocket"
    "time"
)

type Client struct {
    hub    *Hub
    conn   *websocket.Conn
    send   chan interface{}
    UserID string
}

const (
    writeWait      = 10 * time.Second
    pongWait       = 60 * time.Second
    pingPeriod     = (pongWait * 9) / 10
    maxMessageSize = 512 * 1024 // 512KB
)

func NewClient(hub *Hub, conn *websocket.Conn, userID string) *Client {
    return &Client{
        hub:    hub,
        conn:   conn,
        send:   make(chan interface{}, 256),
        UserID: userID,
    }
}

// ReadPump 读取消息
func (c *Client) ReadPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    c.conn.SetReadDeadline(time.Now().Add(pongWait))
    c.conn.SetPongHandler(func(string) error {
        c.conn.SetReadDeadline(time.Now().Add(pongWait))
        return nil
    })
    
    for {
        var message map[string]interface{}
        err := c.conn.ReadJSON(&message)
        if err != nil {
            break
        }
        
        // 处理客户端消息（如心跳、状态上报等）
        c.handleMessage(message)
    }
}

// WritePump 发送消息
func (c *Client) WritePump() {
    ticker := time.NewTicker(pingPeriod)
    defer func() {
        ticker.Stop()
        c.conn.Close()
    }()
    
    for {
        select {
        case message, ok := <-c.send:
            c.conn.SetWriteDeadline(time.Now().Add(writeWait))
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            if err := c.conn.WriteJSON(message); err != nil {
                return
            }
            
        case <-ticker.C:
            c.conn.SetWriteDeadline(time.Now().Add(writeWait))
            if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

func (c *Client) handleMessage(message map[string]interface{}) {
    // 处理心跳、状态上报等
    msgType, ok := message["type"].(string)
    if !ok {
        return
    }
    
    switch msgType {
    case "heartbeat":
        // 心跳保活
    case "status_update":
        // 设备状态更新
    }
}
```

### 6.3 WebSocket Handler

```go
// internal/api/handler/websocket.go
package handler

import (
    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin: func(r *http.Request) bool {
        return true // 生产环境需要验证 origin
    },
}

type WebSocketHandler struct {
    hub *websocket.Hub
}

func NewWebSocketHandler(hub *websocket.Hub) *WebSocketHandler {
    return &WebSocketHandler{
        hub: hub,
    }
}

func (h *WebSocketHandler) HandleWebSocket(c *gin.Context) {
    // 获取用户 ID（从 JWT Token 中）
    userID := c.GetString("user_id")
    if userID == "" {
        c.JSON(401, gin.H{"error": "未授权"})
        return
    }
    
    // 升级连接
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }
    
    // 创建客户端
    client := websocket.NewClient(h.hub, conn, userID)
    h.hub.register <- client
    
    // 启动读写协程
    go client.WritePump()
    go client.ReadPump()
}
```

---

## 7. 安全设计

### 7.1 认证中间件

```go
// internal/api/middleware/auth.go
package middleware

import (
    "github.com/gin-gonic/gin"
    "github.com/supabase-community/supabase-go"
)

func AuthMiddleware(supabaseClient *supabase.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从 Header 获取 Token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "未授权"})
            c.Abort()
            return
        }
        
        // 去除 "Bearer " 前缀
        token := strings.TrimPrefix(authHeader, "Bearer ")
        
        // 验证 JWT Token
        user, err := supabaseClient.Auth.User(token)
        if err != nil {
            c.JSON(401, gin.H{"error": "Token 无效"})
            c.Abort()
            return
        }
        
        // 设置用户信息到上下文
        c.Set("user_id", user.ID)
        c.Set("user", user)
        c.Next()
    }
}
```

### 7.2 数据安全

#### 7.2.1 敏感数据加密

```go
// 使用 Supabase 的 Row Level Security (RLS)
// 确保用户只能访问自己的数据
```

#### 7.2.2 SQL 注入防护

```go
// 使用参数化查询
db.From("workflows").
    Select("*").
    Eq("user_id", userID). // 自动转义
    Execute()
```

### 7.3 API 安全

#### 7.3.1 限流策略

```go
// internal/api/middleware/rate_limit.go
package middleware

import (
    "github.com/gin-gonic/gin"
    "github.com/ulule/limiter/v3"
    "github.com/ulule/limiter/v3/drivers/store/memory"
)

func RateLimitMiddleware() gin.HandlerFunc {
    // 全局限流：100 请求/分钟
    rate := limiter.Rate{
        Period: 1 * time.Minute,
        Limit:  100,
    }
    
    store := memory.NewStore()
    instance := limiter.New(store, rate)
    
    return func(c *gin.Context) {
        // 使用 IP 作为限流 key
        key := c.ClientIP()
        
        context, err := instance.Get(c, key)
        if err != nil {
            c.JSON(500, gin.H{"error": "限流检查失败"})
            c.Abort()
            return
        }
        
        // 设置响应头
        c.Header("X-RateLimit-Limit", strconv.FormatInt(context.Limit, 10))
        c.Header("X-RateLimit-Remaining", strconv.FormatInt(context.Remaining, 10))
        c.Header("X-RateLimit-Reset", strconv.FormatInt(context.Reset, 10))
        
        if context.Reached {
            c.JSON(429, gin.H{"error": "请求过于频繁"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

#### 7.3.2 CORS 配置

```go
// internal/api/middleware/cors.go
package middleware

import (
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc {
    config := cors.Config{
        AllowOrigins:     []string{"https://app.jarvis.com", "tauri://localhost"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    }
    
    return cors.New(config)
}
```

---

## 8. 性能优化

### 8.1 缓存策略

#### 8.1.1 多级缓存

```
客户端缓存 → Redis 缓存 → 数据库
```

#### 8.1.2 Redis 缓存实现

```go
// internal/pkg/cache/redis.go
package cache

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/redis/go-redis/v9"
)

type RedisCache struct {
    client *redis.Client
}

func NewRedisCache(addr, password string) (*RedisCache, error) {
    client := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       0,
    })
    
    // 测试连接
    if err := client.Ping(context.Background()).Err(); err != nil {
        return nil, err
    }
    
    return &RedisCache{client: client}, nil
}

// Get 获取缓存
func (c *RedisCache) Get(ctx context.Context, key string) (interface{}, error) {
    val, err := c.client.Get(ctx, key).Result()
    if err != nil {
        return nil, err
    }
    
    var result interface{}
    if err := json.Unmarshal([]byte(val), &result); err != nil {
        return nil, err
    }
    
    return result, nil
}

// Set 设置缓存
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    return c.client.Set(ctx, key, data, expiration).Err()
}

// Delete 删除缓存
func (c *RedisCache) Delete(ctx context.Context, key string) error {
    return c.client.Del(ctx, key).Err()
}

// DeletePattern 批量删除
func (c *RedisCache) DeletePattern(ctx context.Context, pattern string) error {
    iter := c.client.Scan(ctx, 0, pattern, 0).Iterator()
    for iter.Next(ctx) {
        if err := c.client.Del(ctx, iter.Val()).Err(); err != nil {
            return err
        }
    }
    return iter.Err()
}
```

#### 8.1.3 缓存失效策略

```go
// 数据更新时删除相关缓存
func (s *WorkflowService) UpdateWorkflow(ctx context.Context, workflowID, userID string, data *model.UpdateWorkflowData) error {
    // 更新数据库
    if err := s.workflowRepo.Update(ctx, workflowID, data); err != nil {
        return err
    }
    
    // 删除相关缓存
    s.cache.Delete(ctx, fmt.Sprintf("workflow:%s", workflowID))
    s.cache.DeletePattern(ctx, fmt.Sprintf("workflows:user:%s:*", userID))
    
    return nil
}
```

### 8.2 数据库查询优化

#### 8.2.1 索引优化

```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_workflows_user_category ON public.workflows(user_id, category);
CREATE INDEX idx_tasks_user_status ON public.tasks(user_id, status);
CREATE INDEX idx_logs_created_at ON public.logs(created_at DESC);

-- 为 JSONB 字段创建 GIN 索引
CREATE INDEX idx_workflows_definition ON public.workflows USING GIN(definition);
```

#### 8.2.2 分页优化

```go
// 使用游标分页（大数据量时性能更好）
func (r *WorkflowRepository) FindWithCursor(ctx context.Context, userID, cursor string, limit int) ([]*model.Workflow, string, error) {
    query := `
        SELECT * FROM workflows 
        WHERE user_id = $1 AND id > $2
        ORDER BY id ASC 
        LIMIT $3
    `
    
    var workflows []*model.Workflow
    err := r.db.Select(&workflows, query, userID, cursor, limit)
    if err != nil {
        return nil, "", err
    }
    
    // 返回新游标
    var nextCursor string
    if len(workflows) > 0 {
        nextCursor = workflows[len(workflows)-1].ID
    }
    
    return workflows, nextCursor, nil
}
```

### 8.3 监控与日志

#### 8.3.1 日志设计

```go
// internal/pkg/logger/logger.go
package logger

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

var Logger *zap.Logger

func InitLogger(env string) error {
    var config zap.Config
    
    if env == "production" {
        config = zap.NewProductionConfig()
    } else {
        config = zap.NewDevelopmentConfig()
    }
    
    // 配置日志格式
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    // 配置日志输出
    config.OutputPaths = []string{"stdout", "./logs/app.log"}
    config.ErrorOutputPaths = []string{"stderr", "./logs/error.log"}
    
    var err error
    Logger, err = config.Build()
    return err
}

// 使用示例
func (h *WorkflowHandler) GetWorkflows(c *gin.Context) {
    logger.Logger.Info("获取工作流列表",
        zap.String("user_id", c.GetString("user_id")),
        zap.Any("params", c.Request.URL.Query()),
    )
    
    // 业务逻辑...
}
```

#### 8.3.2 性能监控

```go
// internal/api/middleware/metrics.go
package middleware

import (
    "time"
    "github.com/gin-gonic/gin"
)

func MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        method := c.Request.Method
        
        // 处理请求
        c.Next()
        
        // 记录指标
        duration := time.Since(start)
        statusCode := c.Writer.Status()
        
        logger.Logger.Info("API 请求",
            zap.String("method", method),
            zap.String("path", path),
            zap.Int("status", statusCode),
            zap.Duration("duration", duration),
        )
        
        // 慢查询告警（超过 2 秒）
        if duration > 2*time.Second {
            logger.Logger.Warn("慢请求",
                zap.String("method", method),
                zap.String("path", path),
                zap.Duration("duration", duration),
            )
        }
    }
}
```

---

## 9. 部署架构

### 9.1 部署拓扑

```
                          ┌─────────────────┐
                          │   CloudFlare    │
                          │  (CDN + DDoS)   │
                          └─────────────────┘
                                  ↓
                          ┌─────────────────┐
                    │ 负载均衡 (Nginx) │
                          └─────────────────┘
                           ↙              ↘
              ┌──────────────┐      ┌──────────────┐
        │ API 服务器 1  │      │ API 服务器 2  │
              │  (Go Server) │      │  (Go Server) │
              └──────────────┘      └──────────────┘
                       ↓                    ↓
                          ┌─────────────────┐
                          │   Supabase      │
                          │ (Database+Auth) │
                          └─────────────────┘
                                  ↓
                          ┌─────────────────┐
                          │  Redis Cluster  │
                          └─────────────────┘
```

### 9.2 容器化部署

#### 9.2.1 Dockerfile

```dockerfile
# 构建阶段
FROM golang:1.21-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 编译
RUN CGO_ENABLED=0 GOOS=linux go build -o server ./cmd/server

# 生产阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata

WORKDIR /root/

# 复制二进制文件
COPY --from=builder /app/server .

# 复制配置文件
COPY --from=builder /app/.env.production .env

EXPOSE 8080

CMD ["./server"]
```

#### 9.2.2 Docker Compose

```yaml
version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - ENV=production
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_KEY=${SUPABASE_KEY}
      - REDIS_URL=redis:6379
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped

volumes:
  redis-data:
```

### 9.3 CI/CD 流程

```yaml
# .github/workflows/deploy.yml
name: Deploy Backend Service

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Run Tests
        run: |
          cd backend
          go test ./...
      
      - name: Build
        run: |
          cd backend
          go build -o server ./cmd/server
      
      - name: Build Docker Image
        run: |
          cd backend
          docker build -t jarvis-backend:latest .
      
      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /app/backend
            docker-compose pull
            docker-compose up -d --force-recreate
```

---

## 10. 开发规范

### 10.1 代码规范

#### 10.1.1 Go 代码规范

```go
// 1. 使用 gofmt 格式化代码
// 2. 遵循 Go 官方命名规范
// 3. 导出函数添加注释

// GetWorkflowByID 根据 ID 获取工作流
// 参数:
//   - ctx: 上下文
//   - workflowID: 工作流 ID
// 返回:
//   - *model.Workflow: 工作流信息
//   - error: 错误信息
func (s *WorkflowService) GetWorkflowByID(ctx context.Context, workflowID string) (*model.Workflow, error) {
    // 实现...
}
```

### 10.2 Git 提交规范

```bash
# 使用 Conventional Commits 规范

feat: 添加工作流列表 API
fix: 修复任务状态更新问题
docs: 更新 API 文档
refactor: 重构认证中间件
test: 添加工作流服务单元测试
chore: 更新依赖包版本
```

### 10.3 测试规范

#### 10.3.1 单元测试

```go
// internal/service/workflow_service_test.go
package service

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestCreateWorkflow(t *testing.T) {
    // 创建 mock
    mockRepo := new(MockWorkflowRepository)
    mockCache := new(MockCacheRepository)
        
    // 设置期望
    mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
    mockCache.On("DeletePattern", mock.Anything, mock.Anything).Return(nil)
    
    // 执行测试
    service := NewWorkflowService(mockRepo, mockCache, nil)
    req := &model.CreateWorkflowRequest{
        Name:        "测试工作流",
        Description: "测试描述",
    }
    
    workflow, err := service.CreateWorkflow(context.Background(), "user-123", req)
    
    // 断言
    assert.NoError(t, err)
    assert.NotNil(t, workflow)
    assert.Equal(t, "测试工作流", workflow.Name)
    mockRepo.AssertExpectations(t)
}
```

---

## 11. 附录

### 11.1 环境变量配置

```bash
# .env.production

# 服务配置
ENV=production
PORT=8080

# Supabase 配置
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_KEY=your-supabase-key
SUPABASE_JWT_SECRET=your-jwt-secret

# Redis 配置
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=

# 日志配置
LOG_LEVEL=info

# 第三方服务
SENTRY_DSN=https://xxx@sentry.io/xxx
```

### 11.2 技术栈版本

| 技术 | 版本 | 备注 |
|------|------|------|
| Go | 1.21+ | 后端语言 |
| Gin | 1.9+ | Web 框架 |
| PostgreSQL | 15+ | 数据库 |
| Redis | 7.x | 缓存 |
| Docker | 24.x | 容器化 |

### 11.3 Phase 1 核心 API 清单

根据 Phase 1 迭代计划，必须实现的核心 API：

**认证相关**
- `POST /api/v1/auth/register` - 用户注册
- `POST /api/v1/auth/login` - 用户登录
- `POST /api/v1/auth/refresh` - 刷新 Token

**用户管理**
- `GET /api/v1/users/profile` - 获取用户信息
- `PUT /api/v1/users/profile` - 更新用户信息
- `GET /api/v1/users/devices` - 获取设备列表
- `POST /api/v1/users/devices` - 注册设备

**工作流管理**
- `GET /api/v1/workflows` - 获取工作流列表
- `POST /api/v1/workflows` - 创建工作流
- `GET /api/v1/workflows/:id` - 获取工作流详情
- `PUT /api/v1/workflows/:id` - 更新工作流
- `DELETE /api/v1/workflows/:id` - 删除工作流
- `POST /api/v1/workflows/import` - 导入工作流
- `GET /api/v1/workflows/:id/export` - 导出工作流

**任务管理**
- `POST /api/v1/tasks` - 创建任务
- `GET /api/v1/tasks` - 获取任务列表
- `GET /api/v1/tasks/:id` - 获取任务详情
- `PUT /api/v1/tasks/:id/status` - 更新任务状态

**文件管理**
- `POST /api/v1/files/upload` - 文件上传
- `GET /api/v1/files/:id` - 获取文件

**日志管理**
- `POST /api/v1/logs` - 上报日志
- `GET /api/v1/logs` - 获取日志列表

**WebSocket**
- `WS /ws` - WebSocket 连接

### 11.4 参考文档

- [Supabase 官方文档](https://supabase.com/docs)
- [Gin 框架文档](https://gin-gonic.com/docs/)
- [Go 标准库文档](https://pkg.go.dev/std)
- [Phase 1 迭代计划](../docs/iteration-plans/phase-1-mvp/backend-service.md)

---

## 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| V1.0 | 2025-11-08 | 初始版本，聚焦 Phase 1 为 PC 端提供 API 服务 | - |

---

**文档状态**: ✅ 已完成  
**最后更新**: 2025-11-08  
**文档维护**: 后端团队

**Phase 1 重点**: 本文档聚焦于为 PC 端提供云端 API 服务，管理后台相关功能将在 Phase 2+ 实施。