# 助手-贾维斯 PC端技术架构设计文档

**版本**: V1.0  
**日期**: 2025-11-08  
**文档状态**: 正式版  
**适用范围**: PC端（Windows/macOS）

---

## 目录

1. [文档概述](#1-文档概述)
2. [架构设计原则](#2-架构设计原则)
3. [整体架构](#3-整体架构)
4. [前端架构](#4-前端架构)
5. [后端引擎架构](#5-后端引擎架构)
6. [关键技术方案](#6-关键技术方案)
7. [技术选型](#7-技术选型)
8. [数据架构](#8-数据架构)
9. [部署架构](#9-部署架构)
10. [安全架构](#10-安全架构)

---

## 1. 文档概述

### 1.1 文档目的

本文档定义了"助手-贾维斯"PC端应用的技术架构设计，为开发团队提供清晰的技术指导，确保系统的高性能、可扩展性和可维护性。

### 1.2 项目背景

"助手-贾维斯"是一款跨平台智能助理，以RPA自动化为执行基础，以Multi-Agent系统为决策核心。PC端作为核心执行平台，负责所有自动化任务的执行和AI决策。

### 1.3 核心设计理念

**驾驶舱与引擎分离**：
- **驾驶舱**（前端）：负责用户交互、可视化编排、状态呈现
- **引擎**（后端）：负责AI决策、任务执行、系统集成

这种架构确保前端的轻量流畅和后端的强大能力完全解耦，提升系统稳定性和扩展性。

---

## 2. 架构设计原则

### 2.1 核心原则

1. **前后端分离**：UI层与执行层完全解耦
2. **模块化设计**：各功能模块独立，低耦合高内聚
3. **跨平台兼容**：统一代码适配Windows和macOS
4. **可扩展性**：支持功能模块和工具的动态扩展
5. **高性能**：优化资源占用，确保流畅体验
6. **安全第一**：数据加密、权限隔离、审计日志

### 2.2 技术约束

- 前端必须轻量，启动时间 < 3秒
- 后端引擎内存占用 < 500MB（执行任务时）
- 支持离线执行本地工作流
- 跨平台代码复用率 > 80%

---

## 3. 整体架构

### 3.1 架构分层

```
┌─────────────────────────────────────────────────────────────┐
│                        用户交互层                            │
│              (工作流设计、AI对话、系统设置)                   │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                   前端应用层 (Tauri 2)                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 工作流设计器 │  │  Agent中心  │  │  系统管理   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 智能录制器   │  │  通话管理   │  │  知识库     │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                  通信桥梁 (Tauri Rust Core)                  │
│            Sidecar生命周期管理 + IPC/HTTP通信                │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│              核心引擎层 (Python Sidecar)                      │
│  ┌────────────────────────────────────────────────┐         │
│  │        AI决策层 (AgentScope)                   │         │
│  │  主管Agent → RPA Agent → 通信Agent → 分析Agent │         │
│  └────────────────────────────────────────────────┘         │
│  ┌────────────────────────────────────────────────┐         │
│  │              能力层 (Toolbox)                  │         │
│  │  GUI自动化 | Web自动化 | 系统集成 | AI服务     │         │
│  └────────────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│              操作系统与目标应用 (Windows/macOS)               │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 数据流向

```
用户操作 → 前端UI → Tauri IPC → Python Engine → 系统API → 目标应用
                                      ↓
                                   AI决策
                                      ↓
目标应用 ← 系统API ← Python Engine ← 工具调用
           ↓
      前端UI ← 实时事件 ← WebSocket ← Python Engine
```

---

## 4. 前端架构

### 4.1 技术栈

- **框架**: Tauri 2（Rust backend + WebView）
- **UI库**: React 18
- **状态管理**: Zustand
- **路由**: React Router v6
- **工作流引擎**: React Flow
- **样式**: Tailwind CSS
- **图表**: ECharts
- **通信**: WebSocket + HTTP

### 4.2 模块架构

```
src/
├── app/                    # 应用入口
├── pages/                  # 页面组件
│   ├── WorkflowDesigner/   # 工作流设计器
│   ├── AgentCenter/        # Agent中心
│   ├── Recorder/           # 智能录制器
│   ├── CallManager/        # 通话管理
│   └── Settings/           # 系统设置
├── components/             # 通用组件
│   ├── nodes/              # 工作流节点组件
│   ├── overlay/            # 叠加窗口组件
│   └── common/             # 公共组件
├── stores/                 # 状态管理
│   ├── workflowStore.ts
│   ├── agentStore.ts
│   └── systemStore.ts
├── services/               # 服务层
│   ├── api.ts              # API调用
│   ├── websocket.ts        # WebSocket连接
│   └── tauri.ts            # Tauri命令
├── hooks/                  # 自定义Hooks
├── utils/                  # 工具函数
└── types/                  # TypeScript类型定义
```

### 4.3 核心功能模块

#### 4.3.1 工作流设计器

```typescript
// 基于React Flow的工作流画布
interface WorkflowDesigner {
  canvas: ReactFlowInstance;          // 画布实例
  nodes: Node[];                       // 节点列表
  edges: Edge[];                       // 连接线
  nodeLibrary: NodeDefinition[];       // 节点库
  elementLocator: ElementLocator;      // 元素定位器
}

// 节点类型定义
type NodeType = 
  | 'ui_automation'    // UI自动化节点
  | 'flow_control'     // 流程控制节点
  | 'integration'      // 集成节点
  | 'file_operation'   // 文件操作节点
  | 'system_operation' // 系统操作节点
  | 'ai_operation';    // AI操作节点
```

#### 4.3.2 智能录制器

```typescript
// 录制器状态管理
interface RecorderState {
  isRecording: boolean;           // 录制状态
  overlayVisible: boolean;        // 叠加窗口可见性
  capturedSteps: RecordedStep[];  // 已录制步骤
  currentElement: UIElement;      // 当前高亮元素
}

// 叠加窗口管理
interface OverlayWindow {
  transparent: boolean;           // 透明窗口
  alwaysOnTop: boolean;           // 置顶
  ignoreMouseEvents: boolean;     // 鼠标穿透
  highlightElement(rect: Rect): void;
}
```

#### 4.3.3 Agent中心

```typescript
// Agent管理
interface AgentManager {
  agents: Agent[];                    // Agent列表
  currentSession: Session;            // 当前会话
  knowledgeBases: KnowledgeBase[];    // 知识库
  tools: Tool[];                      // 工具列表
  
  createAgent(type: AgentType): void;
  chat(message: string): Promise<Response>;
  callTool(tool: Tool, params: any): Promise<any>;
}
```

### 4.4 与后端通信

```typescript
// Tauri命令调用
import { invoke } from '@tauri-apps/api/tauri';

// 执行工作流
await invoke('execute_workflow', { 
  workflowId: 'xxx',
  params: {...}
});

// WebSocket事件监听
websocket.on('workflow_status', (data) => {
  updateWorkflowStatus(data);
});

websocket.on('element_highlight', (rect) => {
  highlightElement(rect);
});
```

---

## 5. 后端引擎架构

### 5.1 技术栈

- **语言**: Python 3.10+
- **框架**: FastAPI（HTTP服务）
- **AI框架**: AgentScope（Multi-Agent系统）
- **GUI自动化**: pywinauto (Windows) / pyobjc (macOS)
- **Web自动化**: Playwright
- **事件监听**: pynput
- **OCR**: Tesseract
- **音频**: sounddevice, pydub
- **打包**: PyInstaller

### 5.2 模块架构

```
engine/
├── main.py                 # 入口文件
├── api/                    # API服务层
│   ├── server.py           # FastAPI服务器
│   └── routes/             # 路由定义
├── core/                   # 核心引擎
│   ├── workflow/           # 工作流引擎
│   │   ├── executor.py     # 执行器
│   │   ├── nodes.py        # 节点实现
│   │   └── scheduler.py    # 调度器
│   ├── agent/              # Agent系统
│   │   ├── manager.py      # Agent管理器
│   │   ├── basic.py        # Basic Agent
│   │   ├── react.py        # ReAct Agent
│   │   └── research.py     # Research Agent
│   ├── recorder/           # 录制器
│   │   ├── monitor.py      # 事件监听
│   │   └── element.py      # 元素定位
│   └── call/               # 通话系统
│       ├── manager.py      # 通话管理
│       ├── audio.py        # 音频处理
│       └── asr_tts.py      # 语音识别/合成
├── tools/                  # 工具集
│   ├── gui/                # GUI自动化
│   │   ├── windows.py      # Windows实现
│   │   └── macos.py        # macOS实现
│   ├── web/                # Web自动化
│   │   └── browser.py      # 浏览器控制
│   ├── system/             # 系统集成
│   │   ├── notification.py # 通知监听
│   │   ├── audio_device.py # 音频设备
│   │   └── clipboard.py    # 剪贴板
│   └── ai/                 # AI服务
│       ├── llm.py          # LLM调用
│       └── embedding.py    # 向量化
├── utils/                  # 工具函数
│   ├── logger.py           # 日志
│   ├── config.py           # 配置
│   └── crypto.py           # 加密
└── models/                 # 数据模型
```

### 5.3 核心引擎设计

#### 5.3.1 工作流引擎

```python
# 工作流执行器
class WorkflowExecutor:
    def __init__(self):
        self.nodes: Dict[str, NodeExecutor] = {}
        self.scheduler = TaskScheduler()
        self.context = ExecutionContext()
    
    async def execute(self, workflow: Workflow, params: dict) -> Result:
        """执行工作流"""
        # 初始化执行上下文
        self.context.init(workflow, params)
        
        # 按拓扑排序执行节点
        for node in self.scheduler.order(workflow.nodes):
            result = await self.execute_node(node)
            if result.failed and node.error_strategy == 'stop':
                break
        
        return self.context.get_result()
    
    async def execute_node(self, node: Node) -> NodeResult:
        """执行单个节点"""
        executor = self.get_executor(node.type)
        return await executor.run(node, self.context)
```

#### 5.3.2 Agent系统

```python
# Agent管理器
class AgentManager:
    def __init__(self):
        self.agents: Dict[str, Agent] = {}
        self.sessions: Dict[str, Session] = {}
        self.tools = ToolRegistry()
    
    def create_agent(self, config: AgentConfig) -> Agent:
        """创建Agent"""
        agent_type = config.type
        if agent_type == 'basic':
            return BasicAgent(config)
        elif agent_type == 'react':
            return ReActAgent(config)
        elif agent_type == 'research':
            return ResearchAgent(config)
    
    async def chat(self, agent_id: str, message: str) -> Response:
        """与Agent对话"""
        agent = self.agents[agent_id]
        session = self.sessions.get(agent_id)
        
        # Agent处理消息
        response = await agent.process(message, session)
        
        # 更新会话
        session.add_message(message, response)
        
        return response
```

#### 5.3.3 录制器系统

```python
# 事件监听器
class EventMonitor:
    def __init__(self):
        self.mouse_listener = None
        self.keyboard_listener = None
        self.is_recording = False
    
    def start_recording(self):
        """开始录制"""
        self.is_recording = True
        
        # 启动鼠标监听
        self.mouse_listener = pynput.mouse.Listener(
            on_move=self.on_mouse_move,
            on_click=self.on_mouse_click
        )
        self.mouse_listener.start()
        
        # 启动键盘监听
        self.keyboard_listener = pynput.keyboard.Listener(
            on_press=self.on_key_press
        )
        self.keyboard_listener.start()
    
    def on_mouse_move(self, x, y):
        """鼠标移动事件"""
        if self.is_recording:
            # 获取指针下的元素
            element = self.get_element_at(x, y)
            # 发送高亮事件到前端
            self.send_highlight_event(element.rect)
    
    def on_mouse_click(self, x, y, button, pressed):
        """鼠标点击事件"""
        if pressed and self.is_recording:
            # 记录点击操作
            element = self.get_element_at(x, y)
            self.record_step('click', element)
```

---

## 6. 关键技术方案

### 6.1 Tauri Sidecar模式

```rust
// Tauri配置 (tauri.conf.json)
{
  "tauri": {
    "bundle": {
      "externalBin": [
        "binaries/engine"  // Python引擎可执行文件
      ]
    }
  }
}

// Rust端管理Sidecar
use tauri::api::process::{Command, CommandEvent};

fn start_engine() -> Result<Child, String> {
    let (mut rx, child) = Command::new_sidecar("engine")
        .expect("failed to create engine command")
        .spawn()
        .expect("Failed to spawn sidecar");
    
    // 监听Sidecar输出
    tauri::async_runtime::spawn(async move {
        while let Some(event) = rx.recv().await {
            match event {
                CommandEvent::Stdout(line) => println!("Engine: {}", line),
                CommandEvent::Stderr(line) => eprintln!("Engine Error: {}", line),
                _ => {}
            }
        }
    });
    
    Ok(child)
}
```

### 6.2 元素定位技术

#### 6.2.1 AXUI定位（优先）

```python
# Windows实现 (pywinauto)
def find_element_windows(locator: dict) -> Element:
    app = Application(backend='uia').connect(title_re='.*')
    
    criteria = {
        'control_type': locator.get('control_type'),
        'name': locator.get('name'),
        'automation_id': locator.get('automation_id')
    }
    
    return app.window(**criteria)

# macOS实现 (pyobjc)
def find_element_macos(locator: dict) -> Element:
    app = NSRunningApplication.runningApplicationsWithBundleIdentifier_(
        locator.get('bundle_id')
    )[0]
    
    element = app.activateWithOptions_(NSApplicationActivateIgnoringOtherApps)
    
    # 使用Accessibility API查找元素
    return element.accessibilityElement(
        matchingRole=locator.get('role'),
        withTitle=locator.get('title')
    )
```

#### 6.2.2 OCR定位（降级方案）

```python
# OCR文字定位
def find_element_by_ocr(text: str) -> Rect:
    # 截取屏幕
    screenshot = pyautogui.screenshot()
    
    # OCR识别
    result = pytesseract.image_to_data(
        screenshot, 
        output_type=pytesseract.Output.DICT
    )
    
    # 查找匹配文字
    for i, word in enumerate(result['text']):
        if text in word:
            return Rect(
                x=result['left'][i],
                y=result['top'][i],
                width=result['width'][i],
                height=result['height'][i]
            )
```

### 6.3 智能录制器叠加窗口

```typescript
// 前端：创建叠加窗口
import { WebviewWindow } from '@tauri-apps/api/window';

const overlayWindow = new WebviewWindow('overlay', {
  url: '/overlay',
  decorations: false,
  transparent: true,
  alwaysOnTop: true,
  fullscreen: true,
  skipTaskbar: true
});

// 设置鼠标穿透
await overlayWindow.setIgnoreCursorEvents(true);

// 监听高亮事件
listen('element_highlight', (event) => {
  const rect = event.payload;
  highlightElement(rect);
});
```

```python
# 后端：发送高亮事件
def send_highlight_event(rect: Rect):
    websocket.emit('element_highlight', {
        'x': rect.x,
        'y': rect.y,
        'width': rect.width,
        'height': rect.height
    })
```

### 6.4 虚拟音频设备

#### 6.4.1 驱动安装

```python
# 检查虚拟音频设备
def check_virtual_audio() -> bool:
    devices = sounddevice.query_devices()
    
    if platform.system() == 'Windows':
        return any('CABLE' in d['name'] for d in devices)
    else:  # macOS
        return any('BlackHole' in d['name'] for d in devices)

# 安装虚拟音频驱动
def install_virtual_audio():
    if platform.system() == 'Windows':
        subprocess.run(['./drivers/vb_cable_setup.exe', '/VERYSILENT'])
    else:  # macOS
        subprocess.run(['./drivers/BlackHole.pkg'])
```

#### 6.4.2 音频设备切换

```python
# 音频设备管理器
class AudioDeviceManager:
    def __init__(self):
        self.original_output = None
        self.original_input = None
        self.virtual_device_name = self.get_virtual_device_name()
    
    def switch_to_virtual(self):
        """切换到虚拟设备"""
        # 保存原始设备
        self.original_output = self.get_default_output()
        self.original_input = self.get_default_input()
        
        # 切换到虚拟设备
        if platform.system() == 'Windows':
            subprocess.run([
                'nircmd', 'setdefaultsounddevice', 
                'CABLE Input', '1'
            ])
            subprocess.run([
                'nircmd', 'setdefaultsounddevice', 
                'CABLE Output', '2'
            ])
        else:  # macOS
            subprocess.run([
                'SwitchAudioSource', '-s', 'BlackHole 2ch'
            ])
            subprocess.run([
                'SwitchAudioSource', '-s', 'BlackHole 2ch', '-t', 'input'
            ])
    
    def restore_original(self):
        """恢复原始设备"""
        if self.original_output:
            self.set_default_output(self.original_output)
        if self.original_input:
            self.set_default_input(self.original_input)
```

#### 6.4.3 AI通话流程

```python
# AI通话管理器
class AICallManager:
    def __init__(self):
        self.audio_manager = AudioDeviceManager()
        self.asr_client = ASRClient()
        self.tts_client = TTSClient()
        self.agent = None
    
    async def handle_incoming_call(self, caller: str):
        """处理来电"""
        # 1. 执行接听工作流
        await self.answer_call()
        
        # 2. 切换音频设备
        self.audio_manager.switch_to_virtual()
        
        # 3. 启动AI对话
        await self.start_conversation()
    
    async def start_conversation(self):
        """开始对话"""
        # 音频输入流
        input_stream = sounddevice.InputStream(
            device=self.audio_manager.virtual_device_name
        )
        
        # 音频输出流
        output_stream = sounddevice.OutputStream(
            device=self.audio_manager.virtual_device_name
        )
        
        async with input_stream, output_stream:
            while self.is_in_call:
                # 捕获对方声音
                audio_data = input_stream.read()
                
                # ASR识别
                text = await self.asr_client.recognize(audio_data)
                
                # Agent处理
                response = await self.agent.process(text)
                
                # TTS合成
                audio = await self.tts_client.synthesize(response)
                
                # 播放AI声音
                output_stream.write(audio)
    
    async def end_call(self):
        """结束通话"""
        self.is_in_call = False
        self.audio_manager.restore_original()
        await self.save_call_record()
```

### 6.5 Playwright持久化浏览器

```python
# 持久化浏览器上下文
from playwright.async_api import async_playwright

async def launch_persistent_browser(user_data_dir: str):
    """启动持久化浏览器"""
    async with async_playwright() as p:
        # 使用用户数据目录，保持登录状态
        browser = await p.chromium.launch_persistent_context(
            user_data_dir=user_data_dir,
            headless=False,
            args=['--disable-blink-features=AutomationControlled']
        )
        
        page = browser.pages[0]
        return browser, page

# Web自动化工作流
class WebAutomation:
    def __init__(self):
        self.browser = None
        self.page = None
    
    async def initialize(self):
        """初始化浏览器"""
        user_data = os.path.join(
            os.path.expanduser('~'),
            '.jarvis/browser_profile'
        )
        self.browser, self.page = await launch_persistent_browser(user_data)
    
    async def navigate(self, url: str):
        """导航到URL"""
        await self.page.goto(url)
    
    async def click(self, selector: str):
        """点击元素"""
        await self.page.click(selector)
    
    async def fill(self, selector: str, text: str):
        """填充输入框"""
        await self.page.fill(selector, text)
```

---

## 7. 技术选型

### 7.1 前端技术选型

| 技术 | 选型 | 理由 |
|------|------|------|
| 框架 | Tauri 2 | 轻量、高性能、原生能力、Sidecar支持 |
| UI库 | React 18 | 生态丰富、组件化、性能优化 |
| 状态管理 | Zustand | 轻量、简单、TypeScript友好 |
| 工作流引擎 | React Flow | 专业的节点编辑器、可定制性强 |
| 样式 | Tailwind CSS | 快速开发、一致性、可定制 |
| 图表 | ECharts | 功能强大、性能好、跨平台 |

### 7.2 后端技术选型

| 技术 | 选型 | 理由 |
|------|------|------|
| 语言 | Python 3.10+ | 丰富的自动化库、AI生态 |
| AI框架 | AgentScope | 专为Multi-Agent设计、消息驱动 |
| Web服务 | FastAPI | 高性能、异步、自动文档 |
| GUI自动化 | pywinauto/pyobjc | 原生API、稳定可靠 |
| Web自动化 | Playwright | 现代、快速、持久化上下文 |
| 事件监听 | pynput | 全局键鼠监听、跨平台 |
| OCR | Tesseract | 开源、准确、跨平台 |
| 打包 | PyInstaller | 独立可执行、无需Python环境 |

### 7.3 选型对比

#### Tauri vs Electron

| 对比项 | Tauri 2 | Electron |
|--------|---------|----------|
| 包体积 | ~10MB | ~100MB |
| 内存占用 | ~50MB | ~200MB |
| 启动速度 | < 1s | ~3s |
| 原生能力 | 强（Rust） | 中（Node.js） |
| Sidecar | 原生支持 | 需手动实现 |
| 安全性 | 高 | 中 |

#### AgentScope vs LangChain

| 对比项 | AgentScope | LangChain |
|--------|------------|-----------|
| Multi-Agent | 原生支持 | 需额外配置 |
| 消息驱动 | 内置 | 需手动实现 |
| 协同模式 | 多种内置 | 有限 |
| 学习曲线 | 较平缓 | 较陡峭 |
| 扩展性 | 强 | 强 |

---

## 8. 数据架构

### 8.1 本地数据存储

```
~/.jarvis/
├── config/                 # 配置文件
│   ├── app.json            # 应用配置
│   ├── auth.json           # 认证信息（加密）
│   └── preferences.json    # 用户偏好
├── data/                   # 数据文件
│   ├── workflows/          # 工作流定义
│   ├── agents/             # Agent配置
│   ├── knowledge_bases/    # 知识库文档
│   └── call_records/       # 通话记录
├── logs/                   # 日志文件
│   ├── app.log
│   ├── engine.log
│   └── error.log
├── cache/                  # 缓存
│   ├── screenshots/        # 截图缓存
│   └── temp/               # 临时文件
└── browser_profile/        # 浏览器配置文件
```

### 8.2 数据模型

```typescript
// 工作流定义
interface Workflow {
  id: string;
  name: string;
  description: string;
  version: string;
  nodes: Node[];
  edges: Edge[];
  variables: Variable[];
  triggers: Trigger[];
  created_at: string;
  updated_at: string;
}

// Agent配置
interface Agent {
  id: string;
  name: string;
  type: 'basic' | 'react' | 'research';
  model: ModelConfig;
  prompt: string;
  knowledge_bases: string[];
  tools: string[];
  memory_config: MemoryConfig;
}

// 执行记录
interface ExecutionRecord {
  id: string;
  workflow_id: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  start_time: string;
  end_time: string;
  logs: Log[];
  screenshots: string[];
  variables: Record<string, any>;
  error?: Error;
}
```

### 8.3 云端同步

```python
# 数据同步管理器
class DataSyncManager:
    def __init__(self):
        self.supabase = SupabaseClient()
        self.sync_queue = Queue()
    
    async def sync_workflow(self, workflow: Workflow):
        """同步工作流到云端"""
        await self.supabase.table('workflows').upsert({
            'id': workflow.id,
            'user_id': self.get_user_id(),
            'data': workflow.to_dict(),
            'updated_at': datetime.now()
        })
    
    async def sync_execution_log(self, log: ExecutionRecord):
        """同步执行日志到云端"""
        await self.supabase.table('execution_logs').insert({
            'user_id': self.get_user_id(),
            'workflow_id': log.workflow_id,
            'status': log.status,
            'logs': log.logs,
            'created_at': log.start_time
        })
```

---

## 9. 部署架构

### 9.1 打包构建

```bash
# 前端构建
cd frontend
npm run build

# Python引擎打包
cd engine
pyinstaller --onefile \
  --add-data "models:models" \
  --add-data "drivers:drivers" \
  --hidden-import=agentscope \
  main.py

# Tauri打包
tauri build
```

### 9.2 安装包结构

```
JarvisInstaller.exe (Windows) / Jarvis.dmg (macOS)
├── Jarvis.exe / Jarvis.app          # 主应用
├── engine.exe / engine              # Python引擎
├── drivers/                         # 虚拟设备驱动
│   ├── vb_cable_setup.exe          # Windows虚拟音频
│   ├── BlackHole.pkg                # macOS虚拟音频
│   └── pyvirtualcam/                # 虚拟摄像头
└── resources/                       # 资源文件
    ├── models/                      # AI模型
    └── config/                      # 默认配置
```

### 9.3 更新机制

```rust
// Tauri更新配置
use tauri::updater;

async fn check_update() -> Result<(), String> {
    let handle = app.app_handle();
    match handle.updater().check().await {
        Ok(update) => {
            if update.is_update_available() {
                // 提示用户更新
                update.download_and_install().await?;
            }
        }
        Err(e) => eprintln!("Failed to check update: {}", e),
    }
    Ok(())
}
```

---

## 10. 安全架构

### 10.1 数据加密

```python
# 敏感数据加密
from cryptography.fernet import Fernet
import keyring

class SecureStorage:
    def __init__(self):
        # 从系统密钥库获取加密密钥
        key = keyring.get_password('jarvis', 'encryption_key')
        if not key:
            key = Fernet.generate_key()
            keyring.set_password('jarvis', 'encryption_key', key)
        self.cipher = Fernet(key)
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt(self, encrypted: str) -> str:
        """解密数据"""
        return self.cipher.decrypt(encrypted.encode()).decode()

# 使用系统密钥库存储敏感信息
def save_api_key(service: str, api_key: str):
    keyring.set_password('jarvis', f'{service}_api_key', api_key)

def get_api_key(service: str) -> str:
    return keyring.get_password('jarvis', f'{service}_api_key')
```

### 10.2 权限控制

```python
# 权限管理
class PermissionManager:
    def __init__(self):
        self.permissions = {
            'automation': False,        # 自动化权限
            'accessibility': False,     # 辅助功能权限
            'screen_recording': False,  # 屏幕录制权限
            'microphone': False,        # 麦克风权限
            'camera': False,            # 摄像头权限
        }
    
    def request_permission(self, permission: str) -> bool:
        """请求系统权限"""
        if platform.system() == 'Darwin':  # macOS
            return self.request_macos_permission(permission)
        else:  # Windows
            return self.request_windows_permission(permission)
    
    def check_permission(self, permission: str) -> bool:
        """检查权限状态"""
        return self.permissions.get(permission, False)
```

### 10.3 审计日志

```python
# 审计日志
class AuditLogger:
    def __init__(self):
        self.log_file = os.path.join(
            os.path.expanduser('~'),
            '.jarvis/logs/audit.log'
        )
    
    def log_action(self, action: str, details: dict):
        """记录操作日志"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'user': self.get_current_user(),
            'action': action,
            'details': details,
            'ip': self.get_ip_address()
        }
        
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def log_tool_call(self, tool: str, params: dict):
        """记录工具调用"""
        self.log_action('tool_call', {
            'tool': tool,
            'params': self.sanitize_params(params)
        })
```

### 10.4 网络安全

```python
# WebSocket安全连接
import ssl

class SecureWebSocket:
    def __init__(self):
        self.ssl_context = ssl.create_default_context()
        self.token = self.get_auth_token()
    
    async def connect(self, url: str):
        """建立安全连接"""
        headers = {
            'Authorization': f'Bearer {self.token}'
        }
        
        async with websockets.connect(
            url,
            ssl=self.ssl_context,
            extra_headers=headers
        ) as websocket:
            await self.handle_messages(websocket)
```

---

## 附录

### 附录A：核心技术文档

- **Tauri官方文档**: https://tauri.app
- **AgentScope文档**: https://github.com/modelscope/agentscope
- **Playwright文档**: https://playwright.dev
- **React Flow文档**: https://reactflow.dev

### 附录B：开发规范

#### 代码规范
- **前端**: ESLint + Prettier
- **后端**: Black + Flake8
- **Rust**: Rustfmt + Clippy

#### 提交规范
- 使用Conventional Commits
- 示例：`feat(workflow): add node copy feature`

#### 分支策略
- `main`: 生产分支
- `develop`: 开发分支
- `feature/*`: 功能分支
- `hotfix/*`: 紧急修复分支

### 附录C：性能优化指南

#### 前端优化
- 使用React.memo减少不必要渲染
- 懒加载组件和路由
- 虚拟列表处理大数据
- 使用Web Worker处理计算密集任务

#### 后端优化
- 异步IO处理
- 连接池复用
- 缓存热点数据
- 批量处理减少API调用

---

## 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| V1.0 | 2025-11-08 | 初始版本，完整PC端技术架构设计 | 技术团队 |

---

**文档状态**: ✅ 已完成  
**最后更新**: 2025-11-08  
**文档维护**: 技术架构团队

**说明**: 本文档定义了"助手-贾维斯"PC端的完整技术架构，涵盖前端、后端、关键技术方案、数据架构、部署架构和安全架构。文档将随项目演进持续更新。
